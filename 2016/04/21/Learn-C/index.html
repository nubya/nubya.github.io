<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>《C++ Primer》学习要点整理 | 丁特烦恼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="编程风格使用约定的风格, 可以减少协同工作的障碍, 建立程序猿之间的代码友谊. 虽然朋友说要对别人的代码宽容, 而我认为这就像纵容别人犯罪一样, 遵守一定的代码风格, 能瞬间拉近程序猿之间的距离, 
简要的罗列一下建议遵守的编程风格(谷歌风格):
所有头文件都应该使用 #define 防止头文件被多重包含, 命名格式当是: H当只有数据时使用 struct, 其它一概使用class在类中使用特定的">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ Primer》学习要点整理">
<meta property="og:url" content="http://nubya.github.io/2016/04/21/Learn-C/index.html">
<meta property="og:site_name" content="丁特烦恼">
<meta property="og:description" content="编程风格使用约定的风格, 可以减少协同工作的障碍, 建立程序猿之间的代码友谊. 虽然朋友说要对别人的代码宽容, 而我认为这就像纵容别人犯罪一样, 遵守一定的代码风格, 能瞬间拉近程序猿之间的距离, 
简要的罗列一下建议遵守的编程风格(谷歌风格):
所有头文件都应该使用 #define 防止头文件被多重包含, 命名格式当是: H当只有数据时使用 struct, 其它一概使用class在类中使用特定的">
<meta property="og:updated_time" content="2016-04-21T04:17:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《C++ Primer》学习要点整理">
<meta name="twitter:description" content="编程风格使用约定的风格, 可以减少协同工作的障碍, 建立程序猿之间的代码友谊. 虽然朋友说要对别人的代码宽容, 而我认为这就像纵容别人犯罪一样, 遵守一定的代码风格, 能瞬间拉近程序猿之间的距离, 
简要的罗列一下建议遵守的编程风格(谷歌风格):
所有头文件都应该使用 #define 防止头文件被多重包含, 命名格式当是: H当只有数据时使用 struct, 其它一概使用class在类中使用特定的">
  
    <link rel="alternative" href="/atom.xml" title="丁特烦恼" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">X</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">X</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">X</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Learn-C" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/Learn-C/" class="article-date">
  	<time datetime="2016-04-21T03:03:52.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《C++ Primer》学习要点整理
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a><strong>编程风格</strong></h1><p>使用约定的风格, 可以减少协同工作的障碍, 建立程序猿之间的代码友谊. 虽然朋友说要对别人的代码宽容, 而我认为这就像纵容别人犯罪一样, 遵守一定的代码风格, 能瞬间拉近程序猿之间的距离, </p>
<p><strong>简要的罗列一下建议遵守的编程风格(谷歌风格):</strong></p>
<p>所有头文件都应该使用 #define 防止头文件被多重包含, 命名格式当是: <project><em><path></path></em><file><em>H</em><br>当只有数据时使用 struct, 其它一概使用class<br>在类中使用特定的声明顺序: public: 在 private: 之前, 成员函数在数据成员 (变量) 前<br>整数用0, 实数用0.0, 指针用NULL, 字符(串)用 ‘\0’.<br>类, 结构体, 类型定义 (typedef), 枚举的每个单词首字母均大写, 不包含下划线(大驼峰命名)<br>变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾<br>常量和枚举类型命名在名称前加k: kDaysInAWeek<br>常规函数使用大小写混合(大驼峰命名), get和set函数则要求与变量名匹配(set函数前加set前缀)<br>逗号后添加空格<br>不建议使用using namesapce std</file></project></p>
<p><strong>基础</strong><br><strong>编译与执行:</strong></p>
<p>预处理阶段: 根据字符#开头的命令, 修改原始C程序<br>编译阶段: 将文本文件翻译成汇编程序<br>汇编阶段: 汇编器将编译程序翻译成机器语言指令(机器可识别), 并打包成可重定位目标程序<br>链接阶段: 将调用函数目标文件合并到程序中, 形成可执行目标文件<br>//使用GUN编译器g++, -o选项将输入写入文件, 即用来存放可执行文件<br>$ g++ chapter1.cc -o chapter<br><strong>变量:</strong></p>
<p>变量的作用我认为有以下几点:</p>
<p>给一定大小的内存命名, 方便使用和增加可读性<br>通过变量的类型, 来决定到底访问几个字节长的内存<br>通过变量的来决定如何解释所读取的内存的数据(如有符号数和无符号数的解释不同)<br><strong>左值与右值:</strong></p>
<p>左值可以出现在赋值语句的左边<br>右值只能出现在赋值的右边, 不能出现在赋值语句的左边<br><strong>const关键字:</strong></p>
<p>通过指定const变量为extern, 可以在整个程序中访问const对象<br>const引用是指向const对象的引用, 对象可读不可写<br>指向const对象的指针, 定义时不需要初始化, 可以对指针重新赋值(修改其中保存的内存地址, 指向其他对象), 但所指向对象中的值不能修改(内存中保存的值不能修改)<br>const指针, const指针的值(保存的内存地址的值不能修改)不能修改, 也就是不能使const指针指向其他对象<br>指向const对象的const指针, 既不能修改指针所指向的对象值(内存地址中保存的值), 也不能修改指针的指向(指针中保存的内存地址)<br>// file1.cc<br>extern const int buf_size = 10;<br>// file2.cc<br>extern const int buf_size; //使用file1.cc中的buf_size</p>
<p>//指向const对象的指针<br>const double <em>cptr;<br>//const指针<br>int err_numb = 2;<br>int </em>const cur_err = &amp;err_numb;<br><strong>预处理器:</strong></p>
<p>使用预处理器变量避免头文件的多重包含<br>常用格式:</p>
<p>#<code>ifndef _XXX_H_</code></p>
<p>#<code>define _XXX_H_</code></p>
<p><code>...</code></p>
<p>#<code>endif /* _XXX_H_ */</code><br><strong>指针:</strong></p>
<p>指针保存的是对象的地址<br>数组名会自动转换为指向数组第一个元素的指针.<br>数组的下标访问数组时实际上是使用下标访问指针, 指针是数组的迭代器<br>当类中有指针数据成员, 不能使用系统自带的拷贝构造函数(系统默认导致浅拷贝, 两个对象指针指向同一块动态分配的内存)/赋值函数(=操作符重载), 请自定义(深拷贝)<br><strong>自增/自减操作符</strong></p>
<p>前自增操作加1后返回加1的结果<br>后自增操作保存操作数原来的值, 返回未加1之前的值作为操作的结构<br>自减操作符类似与自增操作符<br><strong>sizeof操作符</strong></p>
<p>注意sizeof是操作符, 用于获得类型的长度<br>对数组做sizeof操作等效于将对其元素类型做sizeof操作的结果乘上数组元素的个数.<br>对指针做sizeof将返回存放指针所需的内存大小<br>对引用做sizeof将返回存放此引用类型对象所需所需的内存大小<br>switch语句执行匹配的case标号相关联的语句后, 会跨越case边界继续执行其他语句, 直到switch结束或者遇到break.<br>复制传参(pass by value)和引用/指针传参(pass by reference):</p>
<p>复制传参无法改变传入实参的值<br>复制传参增加了时间和存储空间的开销, 尽量减少pass by value<br>引用传参相当于传指针<br>返回值也要尽量传递引用(不要返回局部变量的引用)<br><strong>static对象:</strong></p>
<p>类内staitc数据成员不属于某个对象(类内声明, 类外定义). 类内static函数没有this指针(用于处理staitc数据成员)<br>static成员必须在class定义式之外被定义(除非他们是const并且是整型)</p>
<p>class Test {<br>public:<br>    Test(const int p): price(p) { std::cout &lt;&lt; “constructor Test.” &lt;&lt; std::endl; }<br>    void setRate(const double r) { this-&gt;rate = r; }<br>    double getRate() { return rate; };<br>private:<br>    static double rate;  //declare<br>    int price;<br>};<br>double Test::rate = 0.53;  //define</p>
<p>int main(int argc, char *argv[]) {<br>    Test t(10);<br>    Test t1(20);<br>    std::cout &lt;&lt; t.getRate() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; t1.getRate() &lt;&lt; std::endl;<br>    t.setRate(2.22);<br>    std::cout &lt;&lt; t.getRate() &lt;&lt; std::endl;<br>}<br>一旦创建static对象被创建, 在程序结束前不会被销毁. 常用于生命周期跨越多个函数调用的对象</p>
<p><strong>inline函数:</strong></p>
<p>普通函数被调用: 调用前保存寄存器, 返回时恢复上下文, 复制实参, 程序还必须转向一个新的位置执行<br>inline函数在编译时被展开, 从而消除额外的函数执行开销, 常用于小操作函数.内联函数要在头文件中定义<br><strong>重载函数:</strong></p>
<p>确认候选函数(C++名字查找发生在类型检查之前)<br>检查形参个数和形参类型匹配问题<br><strong>函数指针:</strong></p>
<p>重点理解: 函数指针是指向函数的指针<br>直接使用函数名等效于在函数名上取地址操作符</p>
<p>// pf是一个指针, <em>表明了pf的指针身份, pf的类型为bool (const string &amp;, const string &amp;)<br>bool (</em>pf)(const string &amp;, const string &amp;);<br>//类比与普通变量指针, <em>表示ps是指针, ps的类型为const string<br>const string </em>ps;<br>// typedef简化函数指针定义 cmpFun等价于bool <em> (const string &amp;, const string &amp;)<br>typedef bool (</em>cmpFun)(const string &amp;, const string &amp;);<br>cmpFun pf;<br>//typedef简化普通变量指针 pstr等价于 const string <em><br>typedef const string </em>p_str;<br>pstr ps;<br>Stack和Heap<br>Stack是存在于某作用域的一块内存空间<br>Heap是由操作系统提供的一块全局内存空间(可动态分配获得此类空间)</p>
<p>namespace<br>标准库中所有文件被包裹在std命名空间中.</p>
<p>命名空间可以是不连续的</p>
<p>namespace myname {<br>    …<br>}  // 不以分号结束<br>异常<br>异常通过throw抛出对象引发的.异常可以传递给给非引用形参任意类型的对象</p>
<p>通过栈展开(stack unwinding), 沿嵌套函数调用链继续向上, 直至为异常找到一个用于处理异常的catch语句<br>捕获所有异常的catch子句形式为(…)<br>exception类型所定义的唯一操作是what虚函数<br>类<br>类定义了一个新的类型和新的作用域, 切记类定义以分号结束</p>
<p>struct和class的唯一差别在于默认访问级别上, struct的成员默认为public, class成员默认为private<br>类静态成员static: 静态数据成员被类的所有对象所共享, 包括该类派生类的对象, 也就是说, 静态数据成员属于类, 而不属于某个对象. static成员函数没有this指针, 不能被声明为虚函数.<br>隐式形参this: 类中每个成员函数都有一个额外的、隐含的形参(this, const成员函数时, this的类型为const class_type <em>const this)将该成员函数与调用该函数的类对象绑定在一起. 形参this初始化为调用函数的对象的地址<br>常量成员函数: 在成员函数形参表后声明const, 用来表明隐式形参this的类型为const class_type </em><br>构造函数: 与类同名且没有返回值, 一个类可以有多个构造函数, 构造函数不能声明为const. 注意:其中的构造函数的初始化列表有顺序<br>const成员函数: 对于一个不会改变数据的函数, 果断加上const关键字, 表示该函数不允许修改类的数据成员<br>虚函数: 虚函数希望派生类对此函数进行override, 纯虚函数要求派生类必须override这个函数. 注意: 通过基类的引用或指针调用虚函数才能引发动态绑定<br>理解初始化列表, 初始化列表初始化数据成员(注意const对象或引用类型只能初始化不能赋值), 没有初始化列表的的构造函数在函数体中对数据成员赋值. 成员被初始化的顺序就是定义成员的顺序<br>// 链式编程<br>Screen &amp; Screen::move(char c) {<br>    contents[cursor] = c;<br>    return *this;  // this是一个指针, 解引用后是一个类类型Screen<br>}<br>构造函数和析构函数的顺序<br>直接上代码会比较清晰</p>
<p>class Foo {<br>public:<br>    Foo() { std::cout &lt;&lt; “Foo default constructor.” &lt;&lt; std::endl; }<br>    Foo(const Foo &amp;foo) { std::cout &lt;&lt; “Foo copy constructor.” &lt;&lt; std::endl; }<br>    ~Foo() { std::cout &lt;&lt; “Foo deconstructor.” &lt;&lt; std::endl;}<br>};</p>
<p>class Bar {<br>public:<br>    Bar() { std::cout &lt;&lt; “Bar default constructor.” &lt;&lt; std::endl; }<br>    Bar(const Bar &amp;bar) { std::cout &lt;&lt; “Bar copy constructor.” &lt;&lt; std::endl; }<br>    ~Bar() { std::cout &lt;&lt; “Bar deconstructor.” &lt;&lt; std::endl;}<br>};</p>
<p>class Yes {<br>public:<br>    Yes() { std::cout &lt;&lt; “Yes default constructor.” &lt;&lt; std::endl; }<br>    ~Yes() { std::cout &lt;&lt; “Yes deconstructor.” &lt;&lt; std::endl; }<br>};</p>
<p>class Base {<br>public:<br>    Base() { std::cout &lt;&lt; “Base constructor.” &lt;&lt; std::endl; }<br>    ~Base() { std::cout &lt;&lt; “Base deconstructor.” &lt;&lt; std::endl; }<br>private:<br>    Foo foo_;<br>};</p>
<p>class Derived : public Base {<br>public:<br>    Derived() { std::cout &lt;&lt; “Derived constructor.” &lt;&lt; std::endl; }<br>    Derived(const Bar &amp;bar, const Yes &amp;yes);<br>    Derived(const Yes &amp;yes, const Bar &amp;bar);<br>    ~Derived() { std::cout &lt;&lt; “Derived deconstructor.” &lt;&lt; std::endl;}<br>private:<br>    Bar bar<em>;<br>    Yes yes</em>;<br>};</p>
<p>Derived::Derived(const Bar &amp;bar, const Yes &amp;yes) {<br>    std::cout &lt;&lt; “Derived argument: (bar, yes) constructor.” &lt;&lt; std::endl;<br>}</p>
<p>Derived::Derived(const Yes &amp;yes, const Bar &amp;bar) {<br>    std::cout &lt;&lt; “Derived argument (yes, bar) constructor.” &lt;&lt; std::endl;<br>}</p>
<p>int main(int argc, char *argv[]) {<br>    std::cout &lt;&lt; “create simple obejct foo and bar.” &lt;&lt; std::endl;<br>    Foo foo;<br>    Bar bar;<br>    Yes yes;<br>    std::cout &lt;&lt; “create Base class “ &lt;&lt; std::endl;<br>    Base base;<br>    std::cout &lt;&lt; “case 1 : (default constructor) “ &lt;&lt; std::endl;<br>    Derived derived1;<br>    std::cout &lt;&lt; “case 2 : (argument bar, yes)” &lt;&lt; std::endl;<br>    Derived derived2(bar, yes);<br>    std::cout &lt;&lt; “case 3 : (argument yes, bar)” &lt;&lt; std::endl;<br>    Derived derived3(yes, bar);<br>}<br>运行结果:</p>
<p>// 创建三个简单的对象<br>create simple obejct foo and bar.<br>Foo default constructor.<br>Bar default constructor.<br>Yes default constructor.</p>
<p>// 创建基类对象<br>create Base class<br>Foo default constructor.  //先对成员变量初始化<br>Base constructor. // 调用基类构造函数</p>
<p>// Derived调用默认构造函数<br>case 1 : (default constructor)<br>Foo default constructor.  //先调用基类构造函数<br>Base constructor.<br>Bar default constructor.  //自身成员变量初始化<br>Yes default constructor.<br>Derived constructor.  //调用默认构造函数</p>
<p>// 调用以bar, yes为参数的构造函数<br>case 2 : (argument bar, yes)<br>Foo default constructor.<br>Base constructor.<br>Bar default constructor.  //注意bar, yes构造的顺序<br>Yes default constructor.<br>Derived argument: (bar, yes) constructor.</p>
<p>//调用以yes, bar为参数的构造函数<br>case 3 : (argument yes, bar)<br>Foo default constructor.<br>Base constructor.<br>Bar default constructor.  //注意bar, yes构造的顺序<br>Yes default constructor.<br>Derived argument (yes, bar) constructor.</p>
<p>//析构过程(构造过程的逆)<br>Derived deconstructor.  // case3的析构<br>Yes deconstructor.<br>Bar deconstructor.<br>Base deconstructor.<br>Foo deconstructor.</p>
<p>Derived deconstructor.  // case2的析构<br>Yes deconstructor.<br>Bar deconstructor.<br>Base deconstructor.<br>Foo deconstructor.</p>
<p>Derived deconstructor.  // case1的析构<br>Yes deconstructor.<br>Bar deconstructor.<br>Base deconstructor.<br>Foo deconstructor.</p>
<p>// Base的析构<br>Base deconstructor.<br>Foo deconstructor.</p>
<p>//三个简单对象的析构<br>Yes deconstructor.<br>Bar deconstructor.<br>Foo deconstructor.<br>类先初始化成员变量, 然后执行构造函数内部逻辑<br>成员对象初始化的次序完全不受它们在初始化表中次序的影响, 只由成员对象在类中声明的次序决定<br>析构函数的调用顺序和构造函数调用顺序相反<br>参考浅出C++对象模型——理解构造函数、析构函数执行顺序</p>
<p>复制控制<br>具有指针成员的类一般需要定义自己的复制控制(防止浅拷贝), 复制构造或赋值操作符应该显式使用基类的复制构造或赋值操作符<br>复制构造函数: 形参通常为const引用, 一般不设置为explicit. 禁用复制需要将复制构造函数声明为private. (含有指针数据成员时, 避免浅拷贝应该定义复制构造函数)<br>赋值操作符: 类内赋值操作符重载, 包含隐式this形参, 右操作数一般为const引用, 返回值一般应该为引用.<br>析构函数: 资源回收, 尤其是指针所指向的动态分配的内存, 析构函数不可重载<br>拷贝赋值函数(赋值操作符重载): </p>
<ol>
<li>检测值是否自我赋值(self assignment, 地址比较 this == &amp;object)</li>
<li>左值内存delete清空</li>
<li>分配与右值相同大小内存</li>
<li>赋值到左值<br>操作符重载原则</li>
</ol>
<p>赋值(返回对*this的引用), 下标, 调用([])和成员访问箭头必须定义为成员函数<br>符合操作符通常定义为成员函数<br>自增, 自减, 解引用操作符通常定义为类成员函数(改变对象状态或与类型紧密相关)<br>算术, 相等, 关系, 位, 流操作符一般定义为普通非成员函数(设置为友元)<br>对象的创建<br>C++提供两种方法分配和释放未构造的原始内存:</p>
<p>allocator类, 提供可感知类型的内存分配<br>标准库中的operator new和operator delete分配和释放需要的大小的原始的、未类型化的内存</p>
<ol>
<li>ClassName object(para);</li>
</ol>
<p>// 使用new(先分配内存malloc, 指针类型转换 然后调用构造函数)后, 需要delete(先调用析构函数, 再释放内存free)掉分配的堆内存, 防止内存泄漏<br>// 该表达式调用名为operator new的标准库函数分配足够大的原始的未类型化的内存</p>
<ol>
<li>ClassName *object = new ClassName(param);</li>
</ol>
<p>// 当使用delete表示删除动态分配内存时, 首先对object指向的对象析构, 然后调用operator delete的标准库函数释放该对象所用的内存, operator delete不会调用析构函数</p>
<ol>
<li>delete object;</li>
</ol>
<p>//placement new不分配内存, 而是使用已分配但未构造内存的初始化一个对象(接受一个指针)</p>
<ol>
<li>new (place_address) type  // place_address为指针<br>关于C++内存分配的new, operator new, placement new</li>
</ol>
<p>C++创建对象时仅分配用于保存数据成员的堆空间, 成员函数没有单独的空间<br>C++用new创建对象时返回一个对象指针, object指向一个ClassName的对象, C++分配给object的仅仅是存放指针值的空间, 并且用new 动态创建的对象必须用delete来撤销该对象(只有delete对象才会调用其析构函数)<br>相同class的各个对象互为友元(friend)<br>类模版<br>泛型编程是以独立于任何特定类型的方式编写代码<br>模板形参可以是类型形参, 也可以是非类型形参</p>
<p>模板本身并不是一种类型, 当编译器看到模板定义的时候, 不立即产生代码, 只有在看到用到模板时, 编译器才会对模板进行实例化</p>
<p>在类本身的作用域内, 可以使用类模板的非限定名<br>类外定义的类模板成员函数, 必须以关键字template开头, 后接类的模板形参表, 必须指出是那个类的成员并包含模板形参<br>类可以拥有本身为类末班或者函数模板的成员(成员模板). 另外, 此类成员模板定义在类外部时, 需要包含两个模板的形参表<br>模板特化, 我认为是对一些特殊模板形参进行实现(比如模板形参中包含指针的时候)<br>template <class type=""><br>class Queue {<br>public:<br>    Queue() {}; // 可以使用Queue<type>, 由编译器推断<br>private:<br>    QueueItem<type> *head;  // 非类作用域空间必须显式使用模板形参<br>    void destory();<br>};</type></type></class></p>
<p>template <class type=""><br>void Queue<type>::destory() {<br>    // something<br>}<br>STL<br>输出/输出流:</type></class></p>
<p>std::cout, 结果是左操作数的值, 输出操作返回的是输出流本身<br>std::cin, 类似于std::cout, 输入操作符返回器做操作数作为结果<br>顺序容器<br>顺序容器：将单一类型元素聚集起来成为容器, 然后根据位置来存储和访问这些元素. 顺序容器包括vector, list, deque, 顺序容器的适配器stack(基于deque), queue(基于deque), priority_queue(基于vector)<br>vector对象动态增长:</p>
<p>vector的元素连续存储. 其中size()函数统计vector已有元素个数, capacity()指在vector必须重新分配存储空间之前可存储的元素个数.可见vector分配存储空间的策略是增幅小于1时取1, 之后每达到2的次方时倍增(变为原来容量的2倍)</p>
<p>// 测试程序<br>void TestIncrease(std::vector<std::string> &amp;vec) {<br>    std::cout &lt;&lt; “size: “ &lt;&lt; vec.size() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “capacity: “ &lt;&lt; vec.capacity() &lt;&lt; std::endl;<br>}</std::string></p>
<p>void TestVector() {<br>    std::vector<std::string> vec;<br>    TestIncrease(vec);<br>    for(std::vector<std::string>::size_type ix = 0;<br>        ix != 24; ++ix) {<br>        vec.push_back(“hello”);<br>        TestIncrease(vec);<br>    }<br>}<br>// 测试结果, 只保留重要部分<br>size: 0<br>capacity: 0<br>size: 1<br>capacity: 1<br>size: 2<br>capacity: 2<br>…<br>size: 8<br>capacity: 8<br>size: 9<br>capacity: 16<br>…<br>size: 16<br>capacity: 16<br>size: 17<br>capacity: 32<br>…<br>size: 24<br>capacity: 32<br>const_iterator和const的iterator:</std::string></std::string></p>
<p>迭代器可以理解为指针.<br>const_iterator创建的对象, 自身的值可以改变, 但不能改变其指向的元素的值, 对对象解引用返回的是一个const值<br>声明const的迭代器时, 必须初始化, 初始化后, 迭代器自身不可再变, 迭代所指向的元素值可以改变(这里const修饰的是迭代器)<br>关联容器<br>关联容器和顺序容器的本质区别: 关联容器通过key存储和读取元素, 顺序容器通过位置存储和访问容器</p>
<p>map通过key的小于关系排序, 自定义数据结构应该重载&lt;操作符. map迭代器解引用产生pair对象<br>关联容器map, set<br>参考链接及书目</p>
<p><c++ primer=""> 第四版<br>What is the use of “using namespace std”?<br>C/C++ 预处理器参考<br>Super fast C++ logging library<br>C++预处理和预定义<br>预处理指令 (Preprocessor Directives)<br>欢迎关注个人微信公众号: wildDev</c++></p>
<p>文／Andrew_liu（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/7ea58631090e" target="_blank" rel="external">http://www.jianshu.com/p/7ea58631090e</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/21/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Learn-C" data-title="《C++ Primer》学习要点整理" data-url="http://nubya.github.io/2016/04/21/Learn-C/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 X
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>